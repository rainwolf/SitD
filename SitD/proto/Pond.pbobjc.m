// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pond.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Pond.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - PondRoot

@implementation PondRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - PondRoot_FileDescriptor

static GPBFileDescriptor *PondRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - Request

@implementation Request

@dynamic hasNewAccount, newAccount;
@dynamic hasDeliver, deliver;
@dynamic hasFetch, fetch;
@dynamic hasUpload, upload;
@dynamic hasDownload, download;
@dynamic hasRevocation, revocation;
@dynamic hasHmacSetup, hmacSetup;
@dynamic hasHmacStrike, hmacStrike;

typedef struct Request__storage_ {
  uint32_t _has_storage_[1];
  NewAccount *newAccount;
  Delivery *deliver;
  Fetch *fetch;
  Upload *upload;
  Download *download;
  SignedRevocation *revocation;
  HMACSetup *hmacSetup;
  HMACStrike *hmacStrike;
} Request__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "newAccount",
        .dataTypeSpecific.className = GPBStringifySymbol(NewAccount),
        .number = Request_FieldNumber_NewAccount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Request__storage_, newAccount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "deliver",
        .dataTypeSpecific.className = GPBStringifySymbol(Delivery),
        .number = Request_FieldNumber_Deliver,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Request__storage_, deliver),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fetch",
        .dataTypeSpecific.className = GPBStringifySymbol(Fetch),
        .number = Request_FieldNumber_Fetch,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Request__storage_, fetch),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "upload",
        .dataTypeSpecific.className = GPBStringifySymbol(Upload),
        .number = Request_FieldNumber_Upload,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Request__storage_, upload),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "download",
        .dataTypeSpecific.className = GPBStringifySymbol(Download),
        .number = Request_FieldNumber_Download,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Request__storage_, download),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "revocation",
        .dataTypeSpecific.className = GPBStringifySymbol(SignedRevocation),
        .number = Request_FieldNumber_Revocation,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Request__storage_, revocation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "hmacSetup",
        .dataTypeSpecific.className = GPBStringifySymbol(HMACSetup),
        .number = Request_FieldNumber_HmacSetup,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Request__storage_, hmacSetup),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "hmacStrike",
        .dataTypeSpecific.className = GPBStringifySymbol(HMACStrike),
        .number = Request_FieldNumber_HmacStrike,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Request__storage_, hmacStrike),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Request class]
                                     rootClass:[PondRoot class]
                                          file:PondRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Request__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Reply

@implementation Reply

@dynamic hasStatus, status;
@dynamic hasAccountCreated, accountCreated;
@dynamic hasFetched, fetched;
@dynamic hasAnnounce, announce;
@dynamic hasUpload, upload;
@dynamic hasDownload, download;
@dynamic hasRevocation, revocation;
@dynamic extraRevocationsArray, extraRevocationsArray_Count;

typedef struct Reply__storage_ {
  uint32_t _has_storage_[1];
  Reply_Status status;
  AccountCreated *accountCreated;
  Fetched *fetched;
  ServerAnnounce *announce;
  UploadReply *upload;
  DownloadReply *download;
  SignedRevocation *revocation;
  NSMutableArray *extraRevocationsArray;
} Reply__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = Reply_Status_EnumDescriptor,
        .number = Reply_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Reply__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "accountCreated",
        .dataTypeSpecific.className = GPBStringifySymbol(AccountCreated),
        .number = Reply_FieldNumber_AccountCreated,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Reply__storage_, accountCreated),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fetched",
        .dataTypeSpecific.className = GPBStringifySymbol(Fetched),
        .number = Reply_FieldNumber_Fetched,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Reply__storage_, fetched),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "announce",
        .dataTypeSpecific.className = GPBStringifySymbol(ServerAnnounce),
        .number = Reply_FieldNumber_Announce,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Reply__storage_, announce),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "upload",
        .dataTypeSpecific.className = GPBStringifySymbol(UploadReply),
        .number = Reply_FieldNumber_Upload,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Reply__storage_, upload),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "download",
        .dataTypeSpecific.className = GPBStringifySymbol(DownloadReply),
        .number = Reply_FieldNumber_Download,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Reply__storage_, download),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "revocation",
        .dataTypeSpecific.className = GPBStringifySymbol(SignedRevocation),
        .number = Reply_FieldNumber_Revocation,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Reply__storage_, revocation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extraRevocationsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SignedRevocation),
        .number = Reply_FieldNumber_ExtraRevocationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Reply__storage_, extraRevocationsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Reply class]
                                     rootClass:[PondRoot class]
                                          file:PondRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Reply__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum Reply_Status

GPBEnumDescriptor *Reply_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000ParseError\000NoRequest\000InternalError\000Id"
        "entityAlreadyKnown\000Overload\000NoSuchAddres"
        "s\000DeliverySignatureInvalid\000IncorrectGene"
        "ration\000MailboxFull\000NoAccount\000OverQuota\000F"
        "ileLargerThanSize\000FileComplete\000NoSuchFil"
        "e\000ResumePastEndOfFile\000GenerationRevoked\000"
        "CannotParseRevocation\000RegistrationDisabl"
        "ed\000HmacKeyAlreadySet\000HmacNotSetup\000HmacIn"
        "correct\000HmacUsed\000HmacRevoked\000";
    static const int32_t values[] = {
        Reply_Status_Ok,
        Reply_Status_ParseError,
        Reply_Status_NoRequest,
        Reply_Status_InternalError,
        Reply_Status_IdentityAlreadyKnown,
        Reply_Status_Overload,
        Reply_Status_NoSuchAddress,
        Reply_Status_DeliverySignatureInvalid,
        Reply_Status_IncorrectGeneration,
        Reply_Status_MailboxFull,
        Reply_Status_NoAccount,
        Reply_Status_OverQuota,
        Reply_Status_FileLargerThanSize,
        Reply_Status_FileComplete,
        Reply_Status_NoSuchFile,
        Reply_Status_ResumePastEndOfFile,
        Reply_Status_GenerationRevoked,
        Reply_Status_CannotParseRevocation,
        Reply_Status_RegistrationDisabled,
        Reply_Status_HmacKeyAlreadySet,
        Reply_Status_HmacNotSetup,
        Reply_Status_HmacIncorrect,
        Reply_Status_HmacUsed,
        Reply_Status_HmacRevoked,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Reply_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Reply_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Reply_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case Reply_Status_Ok:
    case Reply_Status_ParseError:
    case Reply_Status_NoRequest:
    case Reply_Status_InternalError:
    case Reply_Status_IdentityAlreadyKnown:
    case Reply_Status_Overload:
    case Reply_Status_NoSuchAddress:
    case Reply_Status_DeliverySignatureInvalid:
    case Reply_Status_IncorrectGeneration:
    case Reply_Status_MailboxFull:
    case Reply_Status_NoAccount:
    case Reply_Status_OverQuota:
    case Reply_Status_FileLargerThanSize:
    case Reply_Status_FileComplete:
    case Reply_Status_NoSuchFile:
    case Reply_Status_ResumePastEndOfFile:
    case Reply_Status_GenerationRevoked:
    case Reply_Status_CannotParseRevocation:
    case Reply_Status_RegistrationDisabled:
    case Reply_Status_HmacKeyAlreadySet:
    case Reply_Status_HmacNotSetup:
    case Reply_Status_HmacIncorrect:
    case Reply_Status_HmacUsed:
    case Reply_Status_HmacRevoked:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - NewAccount

@implementation NewAccount

@dynamic hasGeneration, generation;
@dynamic hasGroup, group;
@dynamic hasHmacKey, hmacKey;

typedef struct NewAccount__storage_ {
  uint32_t _has_storage_[1];
  uint32_t generation;
  NSData *group;
  NSData *hmacKey;
} NewAccount__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "generation",
        .dataTypeSpecific.className = NULL,
        .number = NewAccount_FieldNumber_Generation,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NewAccount__storage_, generation),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "group",
        .dataTypeSpecific.className = NULL,
        .number = NewAccount_FieldNumber_Group,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NewAccount__storage_, group),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "hmacKey",
        .dataTypeSpecific.className = NULL,
        .number = NewAccount_FieldNumber_HmacKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NewAccount__storage_, hmacKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewAccount class]
                                     rootClass:[PondRoot class]
                                          file:PondRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NewAccount__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountDetails

@implementation AccountDetails

@dynamic hasQueue, queue;
@dynamic hasMaxQueue, maxQueue;

typedef struct AccountDetails__storage_ {
  uint32_t _has_storage_[1];
  uint32_t queue;
  uint32_t maxQueue;
} AccountDetails__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "queue",
        .dataTypeSpecific.className = NULL,
        .number = AccountDetails_FieldNumber_Queue,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountDetails__storage_, queue),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "maxQueue",
        .dataTypeSpecific.className = NULL,
        .number = AccountDetails_FieldNumber_MaxQueue,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AccountDetails__storage_, maxQueue),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountDetails class]
                                     rootClass:[PondRoot class]
                                          file:PondRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountDetails__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountCreated

@implementation AccountCreated

@dynamic hasDetails, details;

typedef struct AccountCreated__storage_ {
  uint32_t _has_storage_[1];
  AccountDetails *details;
} AccountCreated__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "details",
        .dataTypeSpecific.className = GPBStringifySymbol(AccountDetails),
        .number = AccountCreated_FieldNumber_Details,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountCreated__storage_, details),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountCreated class]
                                     rootClass:[PondRoot class]
                                          file:PondRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountCreated__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Delivery

@implementation Delivery

@dynamic hasTo, to;
@dynamic hasGroupSignature, groupSignature;
@dynamic hasGeneration, generation;
@dynamic hasMessage, message;
@dynamic hasOneTimePublicKey, oneTimePublicKey;
@dynamic hasHmacOfPublicKey, hmacOfPublicKey;
@dynamic hasOneTimeSignature, oneTimeSignature;

typedef struct Delivery__storage_ {
  uint32_t _has_storage_[1];
  uint32_t generation;
  NSData *to;
  NSData *groupSignature;
  NSData *message;
  NSData *oneTimePublicKey;
  NSData *oneTimeSignature;
  uint64_t hmacOfPublicKey;
} Delivery__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "to",
        .dataTypeSpecific.className = NULL,
        .number = Delivery_FieldNumber_To,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Delivery__storage_, to),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "groupSignature",
        .dataTypeSpecific.className = NULL,
        .number = Delivery_FieldNumber_GroupSignature,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Delivery__storage_, groupSignature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "generation",
        .dataTypeSpecific.className = NULL,
        .number = Delivery_FieldNumber_Generation,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Delivery__storage_, generation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = NULL,
        .number = Delivery_FieldNumber_Message,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Delivery__storage_, message),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "oneTimePublicKey",
        .dataTypeSpecific.className = NULL,
        .number = Delivery_FieldNumber_OneTimePublicKey,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Delivery__storage_, oneTimePublicKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "hmacOfPublicKey",
        .dataTypeSpecific.className = NULL,
        .number = Delivery_FieldNumber_HmacOfPublicKey,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Delivery__storage_, hmacOfPublicKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed64,
      },
      {
        .name = "oneTimeSignature",
        .dataTypeSpecific.className = NULL,
        .number = Delivery_FieldNumber_OneTimeSignature,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Delivery__storage_, oneTimeSignature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Delivery class]
                                     rootClass:[PondRoot class]
                                          file:PondRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Delivery__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Fetch

@implementation Fetch


typedef struct Fetch__storage_ {
  uint32_t _has_storage_[1];
} Fetch__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Fetch class]
                                     rootClass:[PondRoot class]
                                          file:PondRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(Fetch__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Fetched

@implementation Fetched

@dynamic hasGroupSignature, groupSignature;
@dynamic hasGeneration, generation;
@dynamic hasMessage, message;
@dynamic hasDetails, details;

typedef struct Fetched__storage_ {
  uint32_t _has_storage_[1];
  uint32_t generation;
  NSData *groupSignature;
  NSData *message;
  AccountDetails *details;
} Fetched__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupSignature",
        .dataTypeSpecific.className = NULL,
        .number = Fetched_FieldNumber_GroupSignature,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Fetched__storage_, groupSignature),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "generation",
        .dataTypeSpecific.className = NULL,
        .number = Fetched_FieldNumber_Generation,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Fetched__storage_, generation),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = NULL,
        .number = Fetched_FieldNumber_Message,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Fetched__storage_, message),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "details",
        .dataTypeSpecific.className = GPBStringifySymbol(AccountDetails),
        .number = Fetched_FieldNumber_Details,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Fetched__storage_, details),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Fetched class]
                                     rootClass:[PondRoot class]
                                          file:PondRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Fetched__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServerAnnounce

@implementation ServerAnnounce

@dynamic hasMessage, message;

typedef struct ServerAnnounce__storage_ {
  uint32_t _has_storage_[1];
  Message *message;
} ServerAnnounce__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "message",
        .dataTypeSpecific.className = GPBStringifySymbol(Message),
        .number = ServerAnnounce_FieldNumber_Message,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ServerAnnounce__storage_, message),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServerAnnounce class]
                                     rootClass:[PondRoot class]
                                          file:PondRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServerAnnounce__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Upload

@implementation Upload

@dynamic hasId_p, id_p;
@dynamic hasSize, size;

typedef struct Upload__storage_ {
  uint32_t _has_storage_[1];
  uint64_t id_p;
  int64_t size;
} Upload__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = Upload_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Upload__storage_, id_p),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeFixed64,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = Upload_FieldNumber_Size,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Upload__storage_, size),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Upload class]
                                     rootClass:[PondRoot class]
                                          file:PondRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Upload__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UploadReply

@implementation UploadReply

@dynamic hasResume, resume;

typedef struct UploadReply__storage_ {
  uint32_t _has_storage_[1];
  int64_t resume;
} UploadReply__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "resume",
        .dataTypeSpecific.className = NULL,
        .number = UploadReply_FieldNumber_Resume,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UploadReply__storage_, resume),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UploadReply class]
                                     rootClass:[PondRoot class]
                                          file:PondRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UploadReply__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Download

@implementation Download

@dynamic hasFrom, from;
@dynamic hasId_p, id_p;
@dynamic hasResume, resume;

typedef struct Download__storage_ {
  uint32_t _has_storage_[1];
  NSData *from;
  uint64_t id_p;
  int64_t resume;
} Download__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "from",
        .dataTypeSpecific.className = NULL,
        .number = Download_FieldNumber_From,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Download__storage_, from),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = Download_FieldNumber_Id_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Download__storage_, id_p),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeFixed64,
      },
      {
        .name = "resume",
        .dataTypeSpecific.className = NULL,
        .number = Download_FieldNumber_Resume,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Download__storage_, resume),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Download class]
                                     rootClass:[PondRoot class]
                                          file:PondRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Download__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DownloadReply

@implementation DownloadReply

@dynamic hasSize, size;

typedef struct DownloadReply__storage_ {
  uint32_t _has_storage_[1];
  int64_t size;
} DownloadReply__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = DownloadReply_FieldNumber_Size,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DownloadReply__storage_, size),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DownloadReply class]
                                     rootClass:[PondRoot class]
                                          file:PondRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DownloadReply__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SignedRevocation

@implementation SignedRevocation

@dynamic hasRevocation, revocation;
@dynamic hasSignature, signature;

typedef struct SignedRevocation__storage_ {
  uint32_t _has_storage_[1];
  SignedRevocation_Revocation *revocation;
  NSData *signature;
} SignedRevocation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "revocation",
        .dataTypeSpecific.className = GPBStringifySymbol(SignedRevocation_Revocation),
        .number = SignedRevocation_FieldNumber_Revocation,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SignedRevocation__storage_, revocation),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = SignedRevocation_FieldNumber_Signature,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SignedRevocation__storage_, signature),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SignedRevocation class]
                                     rootClass:[PondRoot class]
                                          file:PondRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SignedRevocation__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SignedRevocation_Revocation

@implementation SignedRevocation_Revocation

@dynamic hasGeneration, generation;
@dynamic hasRevocation, revocation;

typedef struct SignedRevocation_Revocation__storage_ {
  uint32_t _has_storage_[1];
  uint32_t generation;
  NSData *revocation;
} SignedRevocation_Revocation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "generation",
        .dataTypeSpecific.className = NULL,
        .number = SignedRevocation_Revocation_FieldNumber_Generation,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SignedRevocation_Revocation__storage_, generation),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "revocation",
        .dataTypeSpecific.className = NULL,
        .number = SignedRevocation_Revocation_FieldNumber_Revocation,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SignedRevocation_Revocation__storage_, revocation),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SignedRevocation_Revocation class]
                                     rootClass:[PondRoot class]
                                          file:PondRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SignedRevocation_Revocation__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(SignedRevocation)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - HMACSetup

@implementation HMACSetup

@dynamic hasHmacKey, hmacKey;

typedef struct HMACSetup__storage_ {
  uint32_t _has_storage_[1];
  NSData *hmacKey;
} HMACSetup__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hmacKey",
        .dataTypeSpecific.className = NULL,
        .number = HMACSetup_FieldNumber_HmacKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(HMACSetup__storage_, hmacKey),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HMACSetup class]
                                     rootClass:[PondRoot class]
                                          file:PondRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HMACSetup__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - HMACStrike

@implementation HMACStrike

@dynamic hmacsArray, hmacsArray_Count;

typedef struct HMACStrike__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt64Array *hmacsArray;
} HMACStrike__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hmacsArray",
        .dataTypeSpecific.className = NULL,
        .number = HMACStrike_FieldNumber_HmacsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(HMACStrike__storage_, hmacsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeFixed64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HMACStrike class]
                                     rootClass:[PondRoot class]
                                          file:PondRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HMACStrike__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - KeyExchange

@implementation KeyExchange

@dynamic hasPublicKey, publicKey;
@dynamic hasIdentityPublic, identityPublic;
@dynamic hasServer, server;
@dynamic hasDh, dh;
@dynamic hasDh1, dh1;
@dynamic hasGroup, group;
@dynamic hasGroupKey, groupKey;
@dynamic hasGeneration, generation;

typedef struct KeyExchange__storage_ {
  uint32_t _has_storage_[1];
  uint32_t generation;
  NSData *publicKey;
  NSData *identityPublic;
  NSString *server;
  NSData *dh;
  NSData *group;
  NSData *groupKey;
  NSData *dh1;
} KeyExchange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "publicKey",
        .dataTypeSpecific.className = NULL,
        .number = KeyExchange_FieldNumber_PublicKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(KeyExchange__storage_, publicKey),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "identityPublic",
        .dataTypeSpecific.className = NULL,
        .number = KeyExchange_FieldNumber_IdentityPublic,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(KeyExchange__storage_, identityPublic),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "server",
        .dataTypeSpecific.className = NULL,
        .number = KeyExchange_FieldNumber_Server,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(KeyExchange__storage_, server),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dh",
        .dataTypeSpecific.className = NULL,
        .number = KeyExchange_FieldNumber_Dh,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(KeyExchange__storage_, dh),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "group",
        .dataTypeSpecific.className = NULL,
        .number = KeyExchange_FieldNumber_Group,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(KeyExchange__storage_, group),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "groupKey",
        .dataTypeSpecific.className = NULL,
        .number = KeyExchange_FieldNumber_GroupKey,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(KeyExchange__storage_, groupKey),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "generation",
        .dataTypeSpecific.className = NULL,
        .number = KeyExchange_FieldNumber_Generation,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(KeyExchange__storage_, generation),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "dh1",
        .dataTypeSpecific.className = NULL,
        .number = KeyExchange_FieldNumber_Dh1,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(KeyExchange__storage_, dh1),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[KeyExchange class]
                                     rootClass:[PondRoot class]
                                          file:PondRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(KeyExchange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SignedKeyExchange

@implementation SignedKeyExchange

@dynamic hasSigned_p, signed_p;
@dynamic hasSignature, signature;

typedef struct SignedKeyExchange__storage_ {
  uint32_t _has_storage_[1];
  NSData *signed_p;
  NSData *signature;
} SignedKeyExchange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "signed_p",
        .dataTypeSpecific.className = NULL,
        .number = SignedKeyExchange_FieldNumber_Signed_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SignedKeyExchange__storage_, signed_p),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = SignedKeyExchange_FieldNumber_Signature,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SignedKeyExchange__storage_, signature),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SignedKeyExchange class]
                                     rootClass:[PondRoot class]
                                          file:PondRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SignedKeyExchange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Message

@implementation Message

@dynamic hasId_p, id_p;
@dynamic hasTime, time;
@dynamic hasBody, body;
@dynamic hasBodyEncoding, bodyEncoding;
@dynamic hasMyNextDh, myNextDh;
@dynamic hasInReplyTo, inReplyTo;
@dynamic alsoAckArray, alsoAckArray_Count;
@dynamic filesArray, filesArray_Count;
@dynamic detachedFilesArray, detachedFilesArray_Count;
@dynamic hasSupportedVersion, supportedVersion;

typedef struct Message__storage_ {
  uint32_t _has_storage_[1];
  Message_Encoding bodyEncoding;
  int32_t supportedVersion;
  NSData *body;
  NSData *myNextDh;
  NSMutableArray *filesArray;
  NSMutableArray *detachedFilesArray;
  GPBUInt64Array *alsoAckArray;
  uint64_t id_p;
  int64_t time;
  uint64_t inReplyTo;
} Message__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = Message_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Message__storage_, id_p),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeFixed64,
      },
      {
        .name = "time",
        .dataTypeSpecific.className = NULL,
        .number = Message_FieldNumber_Time,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Message__storage_, time),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "body",
        .dataTypeSpecific.className = NULL,
        .number = Message_FieldNumber_Body,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Message__storage_, body),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "bodyEncoding",
        .dataTypeSpecific.enumDescFunc = Message_Encoding_EnumDescriptor,
        .number = Message_FieldNumber_BodyEncoding,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Message__storage_, bodyEncoding),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "myNextDh",
        .dataTypeSpecific.className = NULL,
        .number = Message_FieldNumber_MyNextDh,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Message__storage_, myNextDh),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "inReplyTo",
        .dataTypeSpecific.className = NULL,
        .number = Message_FieldNumber_InReplyTo,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Message__storage_, inReplyTo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "filesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Message_Attachment),
        .number = Message_FieldNumber_FilesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Message__storage_, filesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "detachedFilesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Message_Detachment),
        .number = Message_FieldNumber_DetachedFilesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Message__storage_, detachedFilesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "supportedVersion",
        .dataTypeSpecific.className = NULL,
        .number = Message_FieldNumber_SupportedVersion,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Message__storage_, supportedVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "alsoAckArray",
        .dataTypeSpecific.className = NULL,
        .number = Message_FieldNumber_AlsoAckArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Message__storage_, alsoAckArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Message class]
                                     rootClass:[PondRoot class]
                                          file:PondRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Message__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum Message_Encoding

GPBEnumDescriptor *Message_Encoding_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Raw\000Gzip\000";
    static const int32_t values[] = {
        Message_Encoding_Raw,
        Message_Encoding_Gzip,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Message_Encoding)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Message_Encoding_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Message_Encoding_IsValidValue(int32_t value__) {
  switch (value__) {
    case Message_Encoding_Raw:
    case Message_Encoding_Gzip:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Message_Attachment

@implementation Message_Attachment

@dynamic hasFilename, filename;
@dynamic hasContents, contents;

typedef struct Message_Attachment__storage_ {
  uint32_t _has_storage_[1];
  NSString *filename;
  NSData *contents;
} Message_Attachment__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "filename",
        .dataTypeSpecific.className = NULL,
        .number = Message_Attachment_FieldNumber_Filename,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Message_Attachment__storage_, filename),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "contents",
        .dataTypeSpecific.className = NULL,
        .number = Message_Attachment_FieldNumber_Contents,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Message_Attachment__storage_, contents),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Message_Attachment class]
                                     rootClass:[PondRoot class]
                                          file:PondRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Message_Attachment__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Message)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Message_Detachment

@implementation Message_Detachment

@dynamic hasFilename, filename;
@dynamic hasSize, size;
@dynamic hasPaddedSize, paddedSize;
@dynamic hasChunkSize, chunkSize;
@dynamic hasKey, key;
@dynamic hasURL, URL;

typedef struct Message_Detachment__storage_ {
  uint32_t _has_storage_[1];
  uint32_t chunkSize;
  NSString *filename;
  NSData *key;
  NSString *URL;
  uint64_t size;
  uint64_t paddedSize;
} Message_Detachment__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "filename",
        .dataTypeSpecific.className = NULL,
        .number = Message_Detachment_FieldNumber_Filename,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Message_Detachment__storage_, filename),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = Message_Detachment_FieldNumber_Size,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Message_Detachment__storage_, size),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "paddedSize",
        .dataTypeSpecific.className = NULL,
        .number = Message_Detachment_FieldNumber_PaddedSize,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Message_Detachment__storage_, paddedSize),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "chunkSize",
        .dataTypeSpecific.className = NULL,
        .number = Message_Detachment_FieldNumber_ChunkSize,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Message_Detachment__storage_, chunkSize),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = Message_Detachment_FieldNumber_Key,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Message_Detachment__storage_, key),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = Message_Detachment_FieldNumber_URL,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Message_Detachment__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Message_Detachment class]
                                     rootClass:[PondRoot class]
                                          file:PondRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Message_Detachment__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\006!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Message)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
